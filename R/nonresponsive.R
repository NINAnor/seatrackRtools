#' Load nonresponsive logger sheet for current year
#'
#' This function loads the record of unresponsive loggers. If the filepath provided does not exist, it initialises new sheets.
#' @param file_path String indicating from where the file should be loaded from.
#' @return A LoadedWB containing the unresponsive logger data.
#'
#' @concept nonresponsive
load_nonresponsive_sheet <- function(file_path) {
    # Check if file already exists

    if (file.exists(file_path)) {
        # If so, load it
        wb <- openxlsx2::wb_load(file_path)
        loaded_sheet <- openxlsx2::read_xlsx(wb)
    } else {
        wb <- openxlsx2::wb_workbook()
        loaded_sheet <- tibble(
            logger_serial_no = character(),
            logger_model = character(),
            producer = character(),
            production_year = numeric(),
            project = character(),
            starttime_gmt = as.POSIXct(character()),
            logging_mode = numeric(),
            days_delayed = numeric(),
            programmed_gmt_time = as.POSIXct(character()),
            download_type = character(),
            download_date = as.Date(character()),
            intended_species = character(),
            intended_location = character(),
            comment = character(),
            priority = character(),
            sent = as.POSIXct(character())
        )
    }

    return(LoadedWB$new(data = list(sheet1 = loaded_sheet), wb = wb))
}

#' Load multiple nonresponsive logger sheets
#'
#' This function loads nonresponsive logger sheets for multiple file paths and manufacturers.
#'
#' @param file_paths A character vector of file paths to load.
#' @param manufacturers A character vector of manufacturers, same length as file_paths.
#' @return A named list of tibbles, each containing nonresponsive logger data for the corresponding manufacturer.
#' @examples
#' \dontrun{
#' file_paths <- c("lotek.xlsx", "migratetech.xlsx")
#' manufacturers <- c("Lotek", "Migrate Technology")
#' nonresponsive_list <- load_nonresponsive(file_paths, manufacturers)
#' }
#' @export
#' @concept nonresponsive
load_nonresponsive <- function(file_paths, manufacturers) {
    if (length(file_paths) != length(manufacturers)) {
        stop("file_paths and manufacturers must be the same length.")
    }
    sheets_list <- lapply(seq_along(file_paths), function(i) {
        load_nonresponsive_sheet(file_paths[i])
    })
    names(sheets_list) <- tolower(manufacturers)
    sheet_collection <- LoadedWBCollection$new(sheets_list = sheets_list)

    return(sheet_collection)
}

#' Get all nonresponsive loggers and export
#'
#' Checks the master startup sheets for loggers marked as nonresponsive handled between certain dates
#' and returns per-manufacturer nonresponsive sheets.
#'
#' @param all_metadata_combined Tibble containing combined startup information from master startup sheets, as generated by `load_all_master_import(TRUE)`
#' @param nonresponsive_list A list containing tibbles of unresponsive loggers for different manufacturers.
#' The name of the list element should match the producer name in master_startup (e.g., "Lotek", "MigrateTech").
#' This can be generated with the `load_nonresponsive` function
#' @param start_date Date or character string specifying the start date for considering nonresponsive loggers. If NULL, defaults to January 1st of the current year.
#' @param end_date Date or character string specifying the end date for considering nonresponsive loggers. If NULL, defaults to Inf (no end date).
#'
#' @return Updated list of nonresponsive logger sheets
#' @concept nonresponsive
#' @export
nonresponsive_from_master <- function(all_metadata_combined, nonresponsive_list, start_date = NULL, end_date = Inf) {
    if (is.null(start_date)) {
        start_date <- format(Sys.Date(), "%Y-01-01")
    }

    nonresponsive_rows <- all_metadata_combined$STARTUP_SHUTDOWN[!is.na(all_metadata_combined$STARTUP_SHUTDOWN$download_date) &
        all_metadata_combined$STARTUP_SHUTDOWN$download_date >= as.Date(start_date) &
        all_metadata_combined$STARTUP_SHUTDOWN$download_date <= as.Date(end_date), ]

    nonresponsive_rows$producer_2 <- tolower(nonresponsive_rows$producer)
    # biotrack loggers should go in the lotek sheet
    nonresponsive_rows$producer_2[nonresponsive_rows$producer_2 == "biotrack"] <- "lotek"

    for (manufacturer in tolower(nonresponsive_list$names())) {
        nonresponsive_for_manufacturer <- nonresponsive_rows[nonresponsive_rows$producer_2 == manufacturer, ]

        if (nrow(nonresponsive_for_manufacturer) == 0) {
            next
        }

        new_nonresponsive <- tibble(
            logger_serial_no = nonresponsive_for_manufacturer$logger_serial_no,
            logger_model = nonresponsive_for_manufacturer$logger_model,
            producer = nonresponsive_for_manufacturer$producer,
            production_year = nonresponsive_for_manufacturer$production_year,
            project = nonresponsive_for_manufacturer$project,
            starttime_gmt = nonresponsive_for_manufacturer$starttime_gmt,
            download_type = "Nonresponsive",
            download_date = nonresponsive_for_manufacturer$download_date,
            comment = nonresponsive_for_manufacturer$comment,
            intended_species = nonresponsive_for_manufacturer$intended_species,
            intended_location = nonresponsive_for_manufacturer$intended_location,
            logging_mode = nonresponsive_for_manufacturer$logging_mode,
            days_delayed = nonresponsive_for_manufacturer$days_delayed,
            programmed_gmt_time = nonresponsive_for_manufacturer$programmed_gmt_time,
            priority = NA,
            sent = NA
        )
        nonresponsive_list <- append_to_nonresponsive(nonresponsive_list, new_nonresponsive, manufacturer)
    }
    return(nonresponsive_list)
}

#' Append to nonresponsive list
#'
#' This function appends to the approrpiate sheet in a list of nonresponsive sheets.
#' It will check for duplicate logger IDs and ensure column ordering matches.
#'
#' @param nonresponsive_list A list containing tibbles of unresponsive loggers for different manufacturers.
#' The name of the list element should match the producer name in master_startup (e.g., "Lotek", "MigrateTech").
#' This can be generated with the `load_nonresponsive` function
#' @param new_nonresponsive Tibble containing new rows to be appended.
#' @param manufacturer Character string of name of manufacturer whose nonresponsive sheet is to be appended to.
#' @return Modified nonresponsive_list
#' @concept nonresponsive
#' @export
append_to_nonresponsive <- function(nonresponsive_list, new_nonresponsive, manufacturer) {
    if (!manufacturer %in% names(nonresponsive_list$sheets_list)) {
        return(nonresponsive_list)
    }
    current_rows <- nonresponsive_list$sheets_list[[manufacturer]]$data[[1]]

    missing_cols <- setdiff(names(current_rows), names(new_nonresponsive))
    if (length(missing_cols) > 0) {
        for (col in missing_cols) {
            new_nonresponsive[[col]] <- NA
        }
    }
    new_nonresponsive <- new_nonresponsive[, names(current_rows)]

    all_rows <- rbind(current_rows, new_nonresponsive)
    all_rows_non_dup <- all_rows[!duplicated(all_rows$logger_serial_no), ]
    added_rows <- new_nonresponsive[!new_nonresponsive$logger_serial_no %in% current_rows$logger_serial_no, ]
    nonresponsive_list$sheets_list[[manufacturer]]$data[[1]] <- all_rows_non_dup
    log_success("Added ", nrow(added_rows), " nonresponsive loggers to ", manufacturer, " sheet.")
    return(nonresponsive_list)
}

#' Save multiple nonresponsive logger sheets to Excel files
#'
#' This function iterates through a list of nonresponsive logger sheets and a vector of file paths,
#' saving each sheet to its corresponding file path.
#' @param file_paths A character vector of file paths to save each sheet.
#' @param nonresponsive_list A named list of tibbles, each containing nonresponsive logger data.
#'
#' @return No return value.
#' @examples
#' \dontrun{
#' save_multiple_nonresponsive(nonresponsive_list, file_paths)
#' }
#' @export
#' @concept nonresponsive
save_nonresponsive <- function(file_paths, nonresponsive_list) {
    if (length(nonresponsive_list$sheets_list) != length(file_paths)) {
        stop("nonresponsive_list and file_paths must be the same length.")
    }
    for (i in seq_along(nonresponsive_list$sheets_list)) {
        openxlsx2::write_xlsx(nonresponsive_list$sheets_list[[i]]$data[[1]], file_paths[i], first_row = TRUE, first_active_col = 5, widths = "auto", na.strings = "")
        log_success("Saved nonresponsive sheet to: ", file_paths[i])
    }
}
